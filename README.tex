% Created 2025-05-27 Tue 09:06
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{mathpartir}
\author{Dowland Aiello}
\date{5/26/25}
\title{Strong Normalization of the Simply-Typed Lambda Calculus in Lean by Decomposition Into the SK Combinators}
\hypersetup{
 pdfauthor={Dowland Aiello},
 pdftitle={Strong Normalization of the Simply-Typed Lambda Calculus in Lean by Decomposition Into the SK Combinators},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 30.1 (Org mode 9.7.27)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents

\section{Abstract}
\label{sec:org0e76f1f}

Proofs of strong normalization of the simply-typed lambda calculus have been exhaustively enumerated in the literature. A common strategy invented by W. W. Tait known as "Tait's method," (Robert Harper, 2022) interprets types as sets of "well-behaving" terms which are known to be strongly normalizing and composed of expressions in some such set.
Strong normalization of the typed SK combinator calculus has been comparatively under-studied. Herein, I demonstrate that the typical proof of strong normalization using Tait's method holds for the typed SK combinator calculus. I also show that decomposition of the STLC into the SK combinator calculus simplifies the typical proof of strong normalization.
\section{A Type Discipline for the SK Combinators}
\label{sec:orgceca387}

I consider the usual SK combinator calculus defined as such:

\begin{align}
& K xy = x \\
& S xyz = xz (yz)
\end{align}

A natural interpretation of the combinators as typed functions results in the dependent typing:

\[
\inferrule
  { \Gamma \vdash A : K \ \Gamma,x : A \vdash B : L }
  { \Gamma \vdash (\forall x : A.B) : L}
\]
\[
\inferrule
  { }
  { \Gamma \vdash K : (\forall \alpha, \beta, x : \alpha, y : \beta.\alpha) }
\]
\[
\inferrule
  { }
  { \Gamma \vdash S : (\forall \alpha, \beta, \gamma, x : (\forall x : \alpha, y : \beta.\gamma), y : (\forall x : \alpha, y : \beta.\alpha), z : \alpha.\gamma) }
\]
\section{Decomposition of the Simply-Typed Lambda Calculus into Dependently Typed SK Combinators}
\label{sec:orgbc213ed}

I follow an SK compilation scheme outlined in "The Implementation of Functional Programming Languages" (Peyton Jones, Simon L., 1987):

\begin{align}
(\lambda x.e_{1}\ e_{2})\ arg &= S (\lambda x.e_{1}) (\lambda x.e_{2})\ arg \\
(\lambda x.x) &= SKK \\
(\lambda x.c) &= K c
\end{align}
\section{Proof}
\label{sec:orgb1961a0}
\subsection{Strong Normalization of the Typed SK Combinators}
\label{sec:org12d23e8}
\subsection{Strong Normalization of the STLC}
\label{sec:org16c7d50}
\subsection{Encoding in Lean}
\label{sec:orgc484a71}

\noindent
Peyton Jones, Simon L. (1987). \emph{The Implementation of Functional Programming Languages (Prentice-Hall International Series in Computer Science)}, Prentice-Hall, Inc..

\noindent
Robert Harper (2022). \emph{How to (Re)Invent Taitâ€™s Method}.
\end{document}
